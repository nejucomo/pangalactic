use crate::flexint::{FlexIntEncoding, FromSliceError};
use test_case::test_case;

#[test_case(0x00, &[0x00])]
#[test_case(0x01, &[0x01])]
#[test_case(0x7f, &[0x7f])]
#[test_case(0x80, &[0x80, 0x01])]
#[test_case(0x3fff, &[0xff, 0x7f])]
#[test_case(0x4000, &[0x80, 0x80, 0x01])]
#[test_case(0x4321, &[0xa1, 0x86, 0x01])]
#[test_case(u64::MAX, &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01])]
fn from_into(u: u64, slice: &[u8]) {
    let fei = FlexIntEncoding::from(u);
    assert_eq!(fei.as_slice(), slice);

    let v = u64::try_from(fei).unwrap();
    assert_eq!(u, v);
}

#[test_case(&[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01] => matches Ok(u64::MAX))]
#[test_case(&[0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x02] => matches Err(FromSliceError::Overflow(_)))]
#[test_case(&[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01] => matches Err(FromSliceError::SliceTooLong))]
fn try_from_overflow(slice: &[u8]) -> Result<u64, FromSliceError> {
    let fei = FlexIntEncoding::try_from(slice)?;
    let u = u64::try_from(fei)?;
    Ok(u)
}
